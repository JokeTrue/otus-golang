package core

import (
	"bytes"
	"fmt"
	"go/format"
	"strings"
	"text/template"
)

var (
	preHeader = "// Code generated by cool go-validate tool; DO NOT EDIT.\n"
	header    = `

import (
	"fmt"
	"regexp"
	"strings"
	"errors"
)

type ValidationError struct {
	Field string
	Err   error
}

`
	tmpl = `
func ({{ .StructShortName }} {{ .StructName }}) Validate() ([]ValidationError, error) {
	var errorsList []ValidationError
	{{ range .FieldsValidators }}
	{{- if (eq .FieldType "int")}}
	{{ template "intTmpl" . }}
	{{- end }}
	{{- if (eq .FieldType "string")}}
	{{ template "stringTmpl" . }}
	{{- end }}
	{{- if (eq .FieldType "[]int")}}
	for i, _ := range {{ .StructShortName }}.{{ .FieldName }} {
		{{ $tmp := setupValidatorForSlice . }}
		{{ template "intTmpl" $tmp }}
	}
	{{- end }}
	{{- if (eq .FieldType "[]string")}}
	for i, _ := range {{ .StructShortName }}.{{ .FieldName }} {
		{{ $tmp := setupValidatorForSlice . }}
		{{ template "stringTmpl" $tmp }}
	}
	{{- end }}
	{{ end }}
	return errorsList, nil
}

`
	stringTmpl = `
	{{- if (eq .Func "len")}}
	if len({{.StructShortName}}.{{.FieldName}}) != {{.Args}} {
	  	errorsList = append(errorsList, ValidationError{
			Field: "{{.FieldName}}",
			Err: fmt.Errorf("length expected to be {{.Args}}, not %d", len({{.StructShortName}}.{{.FieldName}})),
	  	})
	}{{- end }}
	{{- if (eq .Func "regexp")}}
	matched, err := regexp.MatchString("{{.Args}}", {{.StructShortName}}.{{.FieldName}})
	if err != nil {
	  	return errorsList, err
	}
	if !matched {
	  	errorsList = append(errorsList, ValidationError{
			Field: "{{.FieldName}}",
			Err: errors.New("value didnt pass regex '{{.Args}}' with a value '{{.StructShortName}}.{{.FieldName}}'"),
	  	})
	}
	{{- end }}
	{{- if (eq .Func "in")}}
	allowedValues := strings.Split("{{.Args}}", ",")
	var passed bool
	for _, i := range allowedValues {
	  	if string({{.StructShortName}}.{{.FieldName}}) == i {
			passed = true
			break
	  	}
	}
	if !passed {
	  	errorsList = append(errorsList, ValidationError{
			Field: "{{.FieldName}}",
			Err: fmt.Errorf("didnt found value in allowed list"),
	  	})
	}
	{{- end }}`
	intTmpl = `
	{{- if (eq .Func "min")}}
	if {{ .StructShortName }}.{{.FieldName}} < {{.Args}} {
		errorsList = append(errorsList, ValidationError{
			Field: "{{.FieldName}}",
			Err: fmt.Errorf("value is expected to be less then {{.Args}}, but it's %d", {{ .StructShortName }}.{{.FieldName}}),
	  	})
	}
	{{- end }}
	{{- if (eq .Func "max")}}
	if {{ .StructShortName }}.{{.FieldName}} > {{.Args}} {
		errorsList = append(errorsList, ValidationError{
			Field: "{{.FieldName}}",
			Err: fmt.Errorf("value is expected to be more then {{.Args}}, but its %d", {{.StructShortName}}.{{.FieldName}}),
	  	})
	}
	{{- end }}
	{{- if (eq .Func "in")}}
	allowedValues := []int{ {{.Args}} }
	var passed bool
	for _, i := range allowedValues {
		if {{ .StructShortName }}.{{.FieldName}} == i {
			passed = true
			break
	  	}
	}
	if !passed {
	  	errorsList = append(errorsList, ValidationError{
			Field: "{{.FieldName}}",
			Err: fmt.Errorf("didnt found value in allowed list"),
	  	})
	}
	{{- end }}`
)

func Generate(pkgName string, validatedStructs []ValidatedStruct) ([]byte, error) {
	var builder bytes.Buffer

	t, err := template.New("structs_validation").Funcs(template.FuncMap{
		"setupValidatorForSlice": func(field fieldValidator) fieldValidator {
			field.FieldType = strings.TrimPrefix(field.FieldType, "[]")
			field.FieldName += "[i]"
			return field
		},
	}).Parse(tmpl)
	if err != nil {
		return nil, err
	}
	_, err = t.New("stringTmpl").Parse(stringTmpl)
	if err != nil {
		return nil, err
	}
	_, err = t.New("intTmpl").Parse(intTmpl)
	if err != nil {
		return nil, err
	}

	builder.WriteString(preHeader)
	builder.WriteString(fmt.Sprintf("package %s", pkgName))
	builder.WriteString(header)

	for _, v := range validatedStructs {
		if len(v.FieldsValidators) > 0 {
			err = t.ExecuteTemplate(&builder, "structs_validation", v)
			if err != nil {
				return nil, err
			}
		}
	}
	code, err := format.Source(builder.Bytes())
	return code, err
}
